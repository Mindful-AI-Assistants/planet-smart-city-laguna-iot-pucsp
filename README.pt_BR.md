<br>
 
 \[[🇮🇹 Italiano](README.it_IT.md)\] \[**[🇧🇷Português](README.pt_BR.md)**\] \[[🇺🇸English](README.md)\]

<br>


<br><br>
 
## <p align="center">  🌐 CDIA Nexus PUC-SP: Hub de Inovação para Água e Energia Inteligentes   
#### <p align="center"> ***Em colaboração com [Planet Smart City](), PUC-SP [Ciência de Dados & IA](), ONU [Objetivos de Desenvolvimento Sustentável (ODS)](), [Starlink]() e [Proptech]() Brasil***

 <br><br>

### <p align="center"> Smart City Laguna IoT – Fortaleza, Brasil 💛💚  

 <br><br>

#### <p align="center"> [![Patrocine Mindful AI Assistants](https://img.shields.io/badge/Sponsor-Mindful%20AI%20%20Assistants-brightgreen?logo=GitHub)](https://github.com/sponsors/Mindful-AI-Assistants)

<br><br>
 
<p align="center">
<img src="https://github.com/user-attachments/assets/34b57670-0c4b-40ec-a2ee-f53134870f30"/>

<br><br>

## [Visão Geral da Apresentação]():

O **CDIA Nexus** é o projeto final de extensão acadêmica e social do **Grupo de Ciência de Dados e Inteligência Artificial da PUC-SP**, com foco na aplicação de **IoT e IA** para **sistemas inteligentes de água e energia** na **Smart City Laguna**, um desenvolvimento urbano pioneiro em Fortaleza, Brasil.

Essa iniciativa foi desenvolvida em parceria com a **Planet Smart City**, **ONU-Habitat** e **Starlink**, alinhada aos **Objetivos de Desenvolvimento Sustentável da ONU (ODS)** e comprometida com **inovação social, inclusão digital e inteligência ambiental**.

🔍 A apresentação destaca:

- Um **Dashboard integrado de Monitoramento de Água & Energia**  
- Análises preditivas com modelos de IA  
- Engajamento comunitário por meio de estratégias orientadas por dados  
- Insights sobre a implantação com **conectividade Starlink** e infraestrutura Planet  

<br>

[_“Dados para o Bem. Inovação com Propósito.”_]()

<!--
 <p align="center">
<img src="https://github.com/user-attachments/assets/20050582-5dcd-4a60-b5db-d345a8404479"/>
-->

<br>

##  [Visão Geral do Projeto]():

Desenvolvido pelo **grupo CDIA da PUC-SP**, este projeto de extensão visa otimizar **sistemas inteligentes de gestão de recursos** na Smart City Laguna – combinando **tecnologia**, **sustentabilidade** e **inovação comunitária** para empoderar regiões em vulnerabilidade.

Com base sólida em **colaboração interdisciplinar** e cooperação internacional, esta iniciativa conecta ciência de dados a aplicações reais para fomentar cidades resilientes, inclusivas e inteligentes.

<br>

## 🌐 [Planet Smart City]():

Fundada em 2015 por **Giovanni Savio** e **Susanna Marchionni**, a Planet Smart City lidera o movimento global por **habitações acessíveis, inteligentes e sustentáveis**. Seus projetos integram:

- Planejamento urbano avançado  
- Tecnologia integrada  
- Iniciativas de construção comunitária  

🌟 Contribuidor-chave: **Stefano Buono**, físico e empreendedor, ex-pesquisador do CERN e fundador da AAA (vendida à Novartis), hoje presidente da LIFTT e CEO da **Newcleo** (inovação em energia nuclear limpa).

🔗 [Visite Planet Smart City](https://planetsmartcity.com.br)

<br>

## [O Projeto Laguna: Inovação Social Inteligente]():

Localizada em **São Gonçalo do Amarante, Ceará**, a **Smart City Laguna** é a cidade inteligente emblemática da Planet no Brasil, com mais de **60 soluções inteligentes**, incluindo:

- Wi-Fi público e rede de IoT  
- Mobilidade urbana e iluminação sustentáveis  
- Drenagem pluvial com pavimentos permeáveis  
- Programas culturais, educacionais e de governança  

<br>

### [No centro deste ecossistema]():  

**O Gestor Comunitário** — um profissional capacitado dedicado a:

- Mobilizar a governança participativa  
- Promover oficinas, educação e engajamento  
- Fortalecer a coesão social e a gestão de longo prazo  

<br>  

## 🌍 [Parcerias Globais]():

Agradecimento especial a [Pedro](), CEO da Proptech Brasil, por liderar com empatia, respeito e integridade. Sua forma de se colocar a serviço dos outros faz toda a diferença.

Estendemos nossa sincera gratidão às organizações e pessoas que tornaram possível a implementação do CDIA PUC-SP. Agradecimentos especiais a:

<br>

| **Organização**           | **Contribuição**                                              |
|---------------------------|---------------------------------------------------------------|
| **Organização das Nações Unidas (ONU)** | Financiamento para aquisição de placas solares        |
| **PUC-SP (CDIA)**         | Projeto e implementação de soluções com IoT e IA              |
| **ONU-Habitat**           | Apoio técnico e diretrizes éticas                             |
| **Starlink**              | Infraestrutura de internet via satélite                       |
| **Planet Smart City**     | Desenvolvimento urbano e suporte presencial                   |
| **Proptech Brasil**       | Implementação local e apoio estratégico                       |

<br>

[Também agradecemos]():

- Líderes locais e membros da comunidade pela confiança e colaboração contínua.  
- A equipe técnica multidisciplinar por sua dedicação a soluções sustentáveis e inovadoras.  
- A todos que contribuíram, direta ou indiretamente, para tornar essa visão uma realidade.

<br>

#### [Juntos](), esses parceiros representam uma abordagem integrada para alcançar os **Objetivos de Desenvolvimento Sustentável**, especialmente em regiões emergentes. 💙🌎

<br>

---
🚛 Em Construcao
---

<br>

# Gêmeo Digital para Monitoramento e Otimização de Energia Residencial - SmartHouse
### Do Código ao Insight: Análise de Dados e Suporte à Decisão

## 🎯 Objetivo do Projeto

Desenvolver uma solução baseada em ciência de dados e inteligência artificial para **monitorar, prever e otimizar o consumo de energia elétrica em uma residência inteligente** (Smart City Laguna). O projeto simula dados de sensores por cômodo e utiliza aprendizado de máquina para antecipar padrões de consumo e propor ações de economia.

<br>

## 📊 Base de Dados Utilizada

Foi utilizada uma base de dados **simulada**, contendo registros diários com as seguintes variáveis:

- `Data`: Dia da medição
- `KW/H`: Consumo total de energia em kWh
- `Quarto1`, `Quarto2`, `Sala`, `Cozinha`, `Piscina`: Quantidade de acionamentos de sensores em cada cômodo
- `Geração Solar`: Energia gerada por painéis solares (simulada)

<br>

## 🔍 Pergunta de Negócio

> “Como prever o consumo diário de energia com base no comportamento por cômodo e, a partir disso, propor medidas automáticas de economia e eficiência energética?”

<br>

##  Metodologia e Etapas Realizadas

1. **Importação e visualização dos dados**
Leitura da planilha com `pandas` e validação dos formatos.
2. **Pré-processamento**
    - Conversão da coluna `Data` para o formato `datetime`.
    - Criação da variável `Dia_ordinal` para modelagem.
    - Cálculo do consumo médio por acionamento por cômodo.
    - Simulação da geração solar e projeção de consumo futuro.
3. **Modelagem Preditiva**
Foi treinado um modelo de **Regressão Linear** para estimar o consumo (`KW/H`) com base no total de acionamentos por cômodo. A previsão para o dia seguinte também foi implementada.
4. **Visualizações**
    - Gráficos de séries temporais com `matplotlib`/`seaborn`.
    - Ranking de cômodos mais consumidores.
    - Representações dos acionamentos por cluster.
    - Painel interativo com Streamlit para visualização em tempo real (opcional).
5. **Exportação de Relatórios**
Geração automática de PDF com dados relevantes, gráficos e previsões.

<br>

##  Resultados Obtidos

- O modelo de regressão apresentou boa capacidade de prever o consumo com base nos acionamentos.
- Identificou-se que **Sala** e **Cozinha** são os cômodos com maior impacto no consumo.
- A **piscina**, embora com poucos acionamentos, apresenta alto consumo médio por acionamento, indicando desperdício; foi retirada do modelo, pois o projeto Laguna se destina a moradia social e não inclui piscina.
- A geração solar é capaz de compensar parte significativa do consumo em horários de pico, se bem gerenciada.

<br>

## Conclusões e Recomendações

- **Automatizar desligamentos** em ambientes com alto uso como sala e cozinha pode gerar economia imediata.
- **Agendar horários de uso** da piscina pode mitigar picos de consumo não justificados.
- **Aproveitar a geração solar** para balancear o uso de aparelhos nos horários de maior geração.
- **Implementar alertas** quando a meta de consumo diário for excedida.

<br>

## 🧾 Entregáveis

- Aplicação Streamlit com visualização de sensores em tempo real.
- Relatório em PDF com métricas de consumo e sugestões.
- Notebook com todo o pipeline de dados, modelo preditivo e análises visuais.

<br>

## 👥 Público-alvo

Este projeto foi desenvolvido para um cliente externo interessado em soluções de **eficiência energética residencial**, com potencial de expansão para condomínios, prédios e cidades inteligentes.

<br>

📌 *Este relatório foi elaborado com base nas práticas de ciência de dados aplicadas ao contexto de consumo energético residencial e tem como objetivo facilitar a tomada de decisão por parte do cliente final.*



<br>

## 📓 Pipeline de Código


<br>

### **Célula 1 — Importação das bibliotecas**

```python
import locale
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score, mean_squared_error
```


<br>

### **Célula 2 — Leitura dos dados**

```python
# Altere o caminho conforme seu ambiente
file_path = "/Users/fabicampanari/Desktop/Project Planet Smart City Laguna/2-CRISP-DM - Project Smart City Laguna/🇧🇷 CRISP-DM_Projeto_Smart_City_Laguna/Consumo_de_Energia_Analise.xlsx"
xls = pd.ExcelFile(file_path)
sheet_names = xls.sheet_names
print(sheet_names)
df = xls.parse('Sheet1')
print(df.head())
df.info()
```


<br>

### **Célula 3 — Pré-processamento de datas**

```python
meses_pt = {
    'jan': '01', 'fev': '02', 'mar': '03', 'abr': '04',
    'mai': '05', 'jun': '06', 'jul': '07',
}
df['Data'] = df['Data'].astype(str)
df['Data'] = df['Data'].str.lower().replace(meses_pt, regex=True)
df['Data'] = pd.to_datetime(df['Data'] + '/2025', format='%d/%m/%Y')
```


<br>

### **Célula 4 — Estatísticas descritivas e correlação**

```python
summary = df.describe()
correlation = df.corr(numeric_only=True)
print(summary)
print(correlation)
```


<br>

### **Célula 5 — [PLOT 1] Distribuição das variáveis**

```python
fig, axes = plt.subplots(2, 3, figsize=(15, 10))
axes = axes.flatten()
cols = df.columns[1:7]
for i, col in enumerate(cols):
    sns.histplot(df[col], kde=True, ax=axes[i], bins=10)
    axes[i].set_title(f'Distribuição - {col}')
    axes[i].set_xlabel(col)
plt.tight_layout()
plt.suptitle("Distribuição das Variáveis", fontsize=16, y=1.02)
plt.show()
```

**Insira aqui para visualizar a distribuição de consumo e acionamentos.**

<br>

### **Célula 6 — [PLOT 2] Evolução do consumo total ao longo do tempo**

```python
plt.figure(figsize=(14, 6))
plt.plot(df['Data'], df['KW/H'], label='Consumo Total (KW/H)', color='blue', linewidth=2)
plt.title('Evolução do Consumo Total de Energia')
plt.xlabel('Data')
plt.ylabel('KW/H')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()
```

**Visualiza a evolução do consumo de energia ao longo do tempo.**

<br>

### **Célula 7 — Agrupamento semanal e [PLOT 3] Acionamentos semanais por cômodo**

```python
df['Semana'] = df['Data'].dt.to_period('W').apply(lambda r: r.start_time)
df_semana = df.groupby('Semana')[['Quarto1', 'Quarto2', 'Sala', 'Cozinha', 'Piscina']].sum()
df_semana.plot(figsize=(12, 6), marker='o')
plt.title('Acionamentos Semanais por Cômodo')
plt.ylabel('Número de Acionamentos')
plt.xlabel('Semana')
plt.xticks(rotation=45)
plt.grid(True)
plt.tight_layout()
plt.show()
```

**Mostra a soma dos acionamentos por semana em cada cômodo.**

<br>

### **Célula 8 — [PLOT 4] Correlação entre acionamentos e consumo**

```python
correlacoes = df[['KW/H', 'Quarto1', 'Quarto2', 'Sala', 'Cozinha', 'Piscina']].corr()['KW/H'][1:]
plt.figure(figsize=(10, 5))
sns.barplot(x=correlacoes.index, y=correlacoes.values, palette='Oranges_r')
plt.title('Correlação entre Acionamentos e Consumo de Energia (kWh)')
plt.ylabel('Correlação')
plt.xlabel('Cômodo')
plt.tight_layout()
plt.show()
```

**Visualiza quais cômodos mais impactam o consumo total.**

<br>

### **Célula 9 — Modelagem preditiva (Regressão Linear) e avaliação**

```python
X = df[['Quarto1', 'Quarto2', 'Sala', 'Cozinha']]
y = df['KW/H']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
modelo = LinearRegression()
modelo.fit(X_train, y_train)
y_pred = modelo.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
print("Erro quadrático médio (MSE):", round(mse, 2))
print("Coeficiente de determinação (R²):", round(r2, 2))
```


<br>

### **Célula 10 — [PLOT 5] Consumo real vs previsto**

```python
plt.figure(figsize=(10, 5))
plt.scatter(y_test, y_pred, alpha=0.7)
plt.plot([y.min(), y.max()], [y.min(), y.max()], 'r--')
plt.xlabel("Consumo real (kWh)")
plt.ylabel("Consumo previsto (kWh)")
plt.title("Consumo Real vs Previsto")
plt.grid(True)
plt.tight_layout()
plt.show()
```

**Avalia visualmente o desempenho do modelo preditivo.**

<br>

### **Célula 11 — Coeficientes do modelo**

```python
coeficientes = pd.Series(modelo.coef_, index=X.columns)
print("\nContribuição de cada cômodo na previsão (coeficientes):")
print(coeficientes.sort_values(ascending=False))
```

**Mostra o peso de cada cômodo na previsão do consumo.**

---

### **Célula 12 — Cálculo de percentuais de acionamento por cômodo**

```python
df['Total_acionamentos'] = df[['Quarto1', 'Quarto2', 'Sala', 'Cozinha']].sum(axis=1)
for comodo in ['Quarto1', 'Quarto2', 'Sala', 'Cozinha', 'Piscina']:
    df[f'{comodo}_pct'] = df[comodo] / df['Total_acionamentos']
```


<br>

### **Célula 13 — [PLOT 6] Método do Cotovelo para KMeans**

```python
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
inertia = []
for k in range(1, 10):
    km = KMeans(n_clusters=k, random_state=42)
    km.fit(X_scaled)
    inertia.append(km.inertia_)
plt.figure(figsize=(8,5))
plt.plot(range(1, 10), inertia, marker='o')
plt.title('Método do Cotovelo')
plt.xlabel('Número de clusters')
plt.ylabel('Inércia')
plt.grid(True)
plt.show()
```

**Escolha visualmente o número ideal de clusters.**

<br>

### **Célula 14 — KMeans e [PLOT 7] Pairplot dos clusters**

```python
kmeans = KMeans(n_clusters=3, random_state=42)
df['Cluster'] = kmeans.fit_predict(X_scaled)
sns.pairplot(df, hue='Cluster', vars=['Quarto1', 'Quarto2', 'Sala', 'Cozinha'], palette='tab10')
plt.suptitle("Padrões de Uso Agrupados por Cluster", y=1.02)
plt.show()
```

**Visualiza agrupamentos de perfis de consumo.**
<br>

### **Célula 15 — Perfil médio por cluster e nomeação dos perfis**

```python
col_pcts = [f'{c}_pct' for c in ['Quarto1', 'Quarto2', 'Sala', 'Cozinha']]
perfil_clusters = df.groupby('Cluster')[['Quarto1', 'Quarto2', 'Sala', 'Cozinha', 'KW/H'] + col_pcts].mean()

def nomear_cluster(row):
    media_kw = df['KW/H'].mean()
    if row['KW/H'] < media_kw * 0.75:
        consumo_total = '🔵 Baixo Consumo'
    elif row['KW/H'] > media_kw * 1.25:
        consumo_total = '🔴 Alto Consumo'
    else:
        consumo_total = '🟡 Consumo Equilibrado'
    altos = []
    for comodo in ['Quarto1', 'Quarto2', 'Sala', 'Cozinha']:
        media_pct = df[f'{comodo}_pct'].mean()
        if row[f'{comodo}_pct'] > media_pct * 1.2:
            altos.append(comodo)
    if consumo_total == '🔵 Baixo Consumo':
        return consumo_total
    if consumo_total == '🟡 Consumo Equilibrado':
        if len(altos) == 0:
            return consumo_total
        else:
            return f"🟠 Consumo Elevado em {', '.join(altos)}"
    if consumo_total == '🔴 Alto Consumo':
        if len(altos) == 0:
            return consumo_total
        else:
            return f"🔴 Alto Consumo (Em {', '.join(altos)})"

perfil_clusters['Perfil'] = perfil_clusters.apply(nomear_cluster, axis=1)
```


<br>

### **Célula 16 — Dicionário de recomendações e exibição por cluster**

```python
def mapear_perfil_para_chave(perfil):
    if perfil == '🔵 Baixo Consumo':
        return perfil
    if perfil == '🟡 Consumo Equilibrado':
        return perfil
    if perfil.startswith('🟠 Consumo Elevado'):
        return '🟠 Consumo Elevado'
    if perfil.startswith('🔴 Alto Consumo'):
        if 'Em' in perfil:
            idx = perfil.index('Em') + 3
            texto = perfil[idx:]
            principal = texto.split(',')[^0].strip()
            if principal in ['Sala']:
                return '🔴 Alto Consumo (Sala/Cozinha)'
            elif principal == 'Cozinha':
                return '🔴 Alto Consumo (Cozinha)'
            else:
                return '🔴 Alto Consumo'
        else:
            return '🔴 Alto Consumo'
    return perfil

recomendacoes = {
    '🔵 Baixo Consumo': [
        "✅ Manter boas práticas já adotadas.",
        "🎁 Oferecer recompensas ou descontos (gamificação).",
        "🔋 Incentivar uso de energia solar / microgeração."
    ],
    '🟡 Consumo Equilibrado': [
        "🔌 Automatizar desligamento de equipamentos em horários fixos.",
        "🕵️ Instalar sensores de presença em quartos e sala.",
        "📊 Enviar relatórios semanais de uso comparativo."
    ],
    '🟠 Consumo Elevado': [
        "🛏️ Automatizar luzes e eletrônicos nos cômodos com consumo elevado.",
        "🕵️ Instalar sensores de presença específicos para os cômodos.",
        "📊 Acompanhar o uso para identificar picos desnecessários."
    ],
    '🔴 Alto Consumo (Sala/Cozinha)': [
        "💧 Agendar funcionamento da bomba da Cozinha fora do pico.",
        "💡 Incentivar uso consciente da iluminação e eletrônicos.",
        "🧠 Sugerir automação e adesão à tarifa branca."
    ],
    '🔴 Alto Consumo (Cozinha)': [
        "🍳 Verificar equipamentos de cozinha para consumo excessivo.",
        "⏰ Controlar horários de uso de forno e geladeira.",
        "💡 Incentivar uso eficiente da iluminação."
    ]
}

for cluster_id, row in perfil_clusters.iterrows():
    print(f"\n=== Cluster {cluster_id} - {row['Perfil']} ===")
    print("📊 Perfil médio de consumo (acionamentos e kWh):")
    print(row[['Quarto1', 'Quarto2', 'Sala', 'Cozinha', 'KW/H']])
    print("\n📈 Percentual médio de acionamentos por cômodo (%):")
    print((row[col_pcts] * 100).round(2))
    print("\n💡 Recomendações:")
    chave = mapear_perfil_para_chave(row['Perfil'])
    if chave in recomendacoes:
        for rec in recomendacoes[chave]:
            print("-", rec)
    else:
        print("- Sem recomendações específicas para este perfil.")
```


<br>

### **Célula 17 — [PLOT 8] Boxplot consumo por cluster**

```python
plt.figure(figsize=(7,5))
sns.boxplot(x='Cluster', y='KW/H', data=df)
plt.title('Distribuição de Consumo (KW/H) por Cluster')
plt.show()
```

**Mostra a variação do consumo total por cluster.**

<br>

### **Célula 18 — [PLOT 9] Heatmap de percentuais por cluster**

```python
heatmap_data = perfil_clusters[col_pcts] * 100
plt.figure(figsize=(8, 5))
sns.heatmap(heatmap_data, annot=True, cmap='YlGnBu', fmt=".2f")
plt.title('Percentual de Acionamentos por Cômodo (%)')
plt.xlabel('Cômodos')
plt.ylabel('Cluster')
plt.show()
```

**Visualiza a distribuição dos acionamentos por cluster.**

<br>

### **Célula 19 — [PLOT 10] Radar dos cômodos por cluster**

```python
categorias = ['Quarto1', 'Quarto2', 'Sala', 'Cozinha']
angles = np.linspace(0, 2 * np.pi, len(categorias), endpoint=False).tolist()
angles += angles[:1]
plt.figure(figsize=(10, 8))
for i, row in perfil_clusters.iterrows():
    valores = [row[cat] for cat in categorias]
    valores += valores[:1]
    plt.polar(angles, valores, label=f'Cluster {i}')
plt.xticks(angles[:-1], categorias)
plt.title('Radar dos Cômodos por Cluster')
plt.legend()
plt.show()
```

**Compara o perfil de acionamento de cada cluster.**

<br>

### **Célula 20 — [PLOT 11] Visualização dos clusters com PCA**

```python
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)
df_plot = pd.DataFrame(X_pca, columns=['Componente 1', 'Componente 2'])
df_plot['Cluster'] = df['Cluster']
plt.figure(figsize=(8,6))
for cluster in df_plot['Cluster'].unique():
    plt.scatter(
        df_plot[df_plot['Cluster'] == cluster]['Componente 1'],
        df_plot[df_plot['Cluster'] == cluster]['Componente 2'],
        label=f'Cluster {cluster}'
    )
plt.title('Visualização dos Clusters com PCA')
plt.xlabel('Componente 1')
plt.ylabel('Componente 2')
plt.legend()
plt.grid(True)
plt.show()
```

**Reduz dimensionalidade para visualizar os clusters em 2D.**

<br>


## 📊 Interpretação dos Gráficos e Perfis

- **Distribuição das variáveis**: Mostra como os acionamentos e o consumo se distribuem.
- **Evolução temporal**: Permite identificar tendências de consumo ao longo dos dias.
- **Acionamentos semanais**: Ajuda a visualizar padrões por cômodo.
- **Correlação**: Mostra a força da relação entre acionamentos e consumo.
- **Consumo real vs previsto**: Avalia a qualidade do modelo preditivo.
- **Clusterização**: Identifica grupos de comportamento similares para recomendações personalizadas.

 <br>

## 💡 Recomendações por Perfil

| Perfil | Recomendações Principais |
| :-- | :-- |
| 🔵 Baixo Consumo | Manter boas práticas, incentivar energia solar, recompensas/gamificação |
| 🟡 Consumo Equilibrado | Automatizar desligamentos, instalar sensores de presença, relatórios comparativos |
| 🟠 Consumo Elevado | Automatizar luzes/eletrônicos, sensores de presença específicos, monitorar picos |
| 🔴 Alto Consumo (Sala/Cozinha) | Agendar bomba fora do pico, uso consciente de iluminação, sugerir automação e tarifa branca |
| 🔴 Alto Consumo (Cozinha) | Verificar equipamentos, controlar horários de uso, incentivar eficiência da iluminação |


<br>

## 🧭 Conclusão

O projeto permite identificar padrões de consumo, prever o uso futuro e recomendar ações para maior eficiência energética, personalizando as recomendações conforme o perfil de uso de cada residência.

<br>

**Observação:**
Altere o caminho do arquivo Excel (`file_path`) conforme seu ambiente.

<br>

**EstA Aanalise foi elaborado com base nas práticas de ciência de dados aplicadas ao contexto de consumo energético residencial e tem como objetivo facilitar a tomada de decisão por parte do cliente final.**










#

##### Copyright 2024 Mindful-AI-Assistants. Código disponibilizado sob a [licença MIT]().
